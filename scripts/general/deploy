#!/bin/bash

set -eo pipefail

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

if [[ -z "$BACKUP_SCRIPT_PATH" ]]; then
  BACKUP_SCRIPT_PATH="$SCRIPT_DIR/backup"
fi
if [[ -z "$REMOTE_BACKUP_DIRECTORY" ]]; then
  REMOTE_BACKUP_DIRECTORY="~"
fi
if [[ -z "$DEPLOY_SCRIPT_PATH" ]]; then
  DEPLOY_SCRIPT_PATH="$SCRIPT_DIR/remote_deploy"
fi

git config --global user.email "$GIT_EMAIL"
git config --global user.name "CI Bot"
git config --global core.fileMode false
sed -i '1,/# :::::::::::::::::::::: cut ::::::::::::::::::::::/d' .gitignore
# remove any .git directories that may exist in vendor libraries* so those
# libraries don't get excluded from our repo. Remember kiddies somedir/*
# returns all files/dirs that are NOT dot (hidden). This protects our repos'
# .git folder from being blown away.
find ./* -type d | grep .git | xargs rm -rf

# Remove unwanted gitignores here. Follow the example below.
# Remove simplesamlphp .gitignore which would cause our config and metadata
# symlinks to be ignored. If it's already not there, GREAT!
# - rm ./vendor/simplesamlphp/simplesamlphp/.gitignore || exit 0

# Commit and push to a "deploy" branch.
git add .
git commit -am "Built assets."
DEPLOY_BRANCH=deploy-$CIRCLE_BRANCH
git push origin $CIRCLE_BRANCH:$DEPLOY_BRANCH -f --tags
echo "If deployment was successful, an artifact should be availible in the origin repo at $DEPLOY_BRANCH."

# @TODO: Restructure this so that it only deploys master on tags or some manual
# workflow so we don't have multiple merges to master mess up production.
if [[ -n "$DEPLOY_USING_SSH" ]] && [[ "$DEPLOY_USING_SSH" != "NO" ]]; then
  if [[ -z "$ENCODED_HOST_MAPPING" ]]; then
    echo "ENCODED_HOST_MAPPING variable needs set up.";
    exit 1
  fi

  # Expected format:
  # {
  #   "dev": { # arbitrary Enviornment name
  #     "branch": "develop",
  #     "ssh_host": "ip-or-hostname.com",
  #     "ssh_user": "hosting_user",
  #     "ssh_port": "22",
  #     "ssh_options": "", # can be a specific key or any other ssh switch
  #     "path": "/var/www/dev/" #path to the root of project
  #   },
  #   "prod": { # Must provide either a "prod" or "live" enviornment
  #     "branch": "main",
  #     "ssh_host": "ip-or-hostname.com",
  #     "ssh_user": "hosting_user",
  #     "ssh_port": "22",
  #     "ssh_options": "", # can be a specific key or any other ssh switch
  #     "path": "/var/www/prod" #path to the root of project
  #   }
  # }

  # Set ☝️ as the environment variable ENCODED_HOST_MAPPING in CircleCI using a
  # command like `cat temporary_host_map_on_my_local.json | base64` and
  # copying the results. This keeps the connection string secure and
  # configurable
  echo $(echo $ENCODED_HOST_MAPPING | base64 -d) > ~/hostmapping.json
  # Variables availible after hostmapping
  # $HOSTING_MAPPING_ENV
  # $HOSTING_MAPPING_SSH_USER
  # $HOSTING_MAPPING_SSH_HOST
  # $HOSTING_MAPPING_SSH_PORT
  # $HOSTING_MAPPING_SSH_OPTIONS
  # $HOSTING_MAPPING_PATH

  eval "$( php  $SCRIPT_DIR/mapping.php $CIRCLE_BRANCH "$( realpath ~/hostmapping.json )" )"
  # @TODO: Add a locking mechanism so that 2 deploys can't happen simultaneously.
  if [[ "$HOSTING_MAPPING_ENV" == "prod" ]] || [[ "$HOSTING_MAPPING_ENV" == "live" ]]; then
    ssh $HOSTING_MAPPING_SSH_USER@$HOSTING_MAPPING_HOST -p$HOSTING_MAPPING_PORT "bash -s " < "$BACKUP_SCRIPT_PATH" "$HOSTING_MAPPING_ENV $HOSTING_MAPPING_PATH" "$REMOTE_BACKUP_DIRECTORY";
  else
    echo "Importing a backup from the canonical environment to $HOSTING_MAPPING_ENV"
    ssh $HOSTING_MAPPING_SSH_USER@$HOSTING_MAPPING_HOST -p$HOSTING_MAPPING_PORT "bash -s " < "$IMPORT_SCRIPT_PATH" "$HOSTING_MAPPING_ENV" "$HOSTING_MAPPING_PATH" "$REMOTE_BACKUP_DIRECTORY";
  fi
   ssh $HOSTING_MAPPING_SSH_USER@$HOSTING_MAPPING_HOST -p$HOSTING_MAPPING_PORT "bash -s " < "$DEPLOY_SCRIPT_PATH" "$HOSTING_MAPPING_ENV" "$HOSTING_MAPPING_PATH" "$DEPLOY_BRANCH" "$DOCROOT";
fi
